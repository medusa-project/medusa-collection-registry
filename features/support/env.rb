# coding: utf-8
# IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# It is recommended to regenerate this file in the future when you upgrade to a
# newer version of cucumber-rails. Consider adding your own code to a new file
# instead of editing this one. Cucumber will automatically load all features/**/*.rb
# files.

require 'cucumber/rails'
require 'json_spec/cucumber'
require 'capybara/poltergeist'
require 'sunspot_test/cucumber'
require 'capybara/mechanize/cucumber'
require 'fileutils'
require 'simplecov'

# Capybara defaults to XPath selectors rather than Webrat's default of CSS3. In
# order to ease the transition to Capybara we set the default here. If you'd
# prefer to use XPath just remove this line and adjust any selectors in your
# steps to use the XPath syntax.
Capybara.default_selector = :css

#This preserves compatibility with Capybara 1.x, under which we started developing
Capybara.match = :prefer_exact

Capybara.server = :puma

#TODO - a general note that as of this writing, 2019-05-16, the selenium based tests are somewhat
# flaky. If you run them through selenium_chrome_headless it is likely that some of them will fail,
# but rerun the failures a few times and eventually they'll all pass. This seems likely due to
# selenium somehow. It's a bit of a mystery, though, as in the fairly recent past they would all pass
# without difficulty. So something significant in the browsers/selenium-webdriver/capybara/etc. must
# have changed. I've spent some time looking at it without much success yet.

Capybara.default_driver = :rack_test
#For this to work chromedriver must be installed on the path. I've
# taken the gem out of the gemfile since it is generally available and
# more up to date through brew, npm, or the like
Capybara.javascript_driver = :selenium_chrome_headless
#Capybara.javascript_driver = :firefox_headless
#Capybara.javascript_driver = :poltergeist
#Capybara.javascript_driver = :webkit
#Capybara.javascript_driver = :selenium
#Capybara.javascript_driver = :selenium_chrome

# By default, any exception happening in your Rails application will bubble up
# to Cucumber so that your scenario will fail. This is a different from how
# your application behaves in the production environment, where an error page will
# be rendered instead.
#
# Sometimes we want to override this default behaviour and allow Rails to rescue
# exceptions and display an error page (just like when the app is running in production).
# Typical scenarios where you want to do this is when you test your error pages.
# There are two ways to allow Rails to rescue exceptions:
#
# 1) Tag your scenario (or feature) with @allow-rescue
#
# 2) Set the value below to true. Beware that doing this globally is not
# recommended as it will mask a lot of errors for you!
#
ActionController::Base.allow_rescue = false

#make sure database is seeded before loading test code - this is necessary because some of the factories, etc. assume
#that the seeded stuff is there
def ensure_db_is_seeded
  # constrains_off_sql = "SET session_replication_role = 'replica'"
  # ActiveRecord::Base.connection.execute(constrains_off_sql)
  # DatabaseCleaner.clean_with(:truncation)
  # constraints_on_sql = "SET session_replication_role = 'origin'"
  # ActiveRecord::Base.connection.execute(constraints_on_sql)
  if StaticPage.count == 0
    load File.join(Rails.root, 'db', 'seeds.rb')
  end
end

DatabaseCleaner.strategy = :transaction
# Possible values are :truncation and :transaction
# The :transaction strategy is faster, but might give you threading problems.
# See https://github.com/cucumber/cucumber-rails/blob/master/features/choose_javascript_database_strategy.feature
Cucumber::Rails::Database.javascript_strategy = :transaction
# ,
#     {except: %w(storage_media producers job_report_producers cfs_files resource_types preservation_priorities static_pages file_format_test_reasons),
#      pre_count: true}

def last_json
  page.source
end

%i(selenium chrome selenium_chrome_headless selenium_chrome poltergeist webkit selenium_chrome_headless_downloading firefox_headless).each do |driver|
  Around("@#{driver}") do |scenario, block|
    begin
      Capybara.current_driver = driver
      block.call
    ensure
      Capybara.use_default_driver
    end
  end
end

Capybara.register_driver(:firefox_headless) do |app|
  options = Selenium::WebDriver::Firefox::Options.new
  options.args << '--headless'
  Capybara::Selenium::Driver.new(app, browser: :firefox, options: options)
end

# Register a driver specially for downloading stuff
# This is basically taken from:
# https://gist.github.com/bbonamin/4b01be9ed5dd1bdaf909462ff4fdca95
CAPYBARA_DOWNLOAD_DIR = Rails.root.join('tmp/test-downloads').to_s
Capybara.register_driver :selenium_chrome_headless_downloading do |app|
  options = Selenium::WebDriver::Chrome::Options.new
  options.add_preference(:download, prompt_for_download: false, default_directory: CAPYBARA_DOWNLOAD_DIR)
  options.add_preference(:browser, set_download_behavior: { behavior: 'allow' })
  options.headless!
  driver = Capybara::Selenium::Driver.new(app, browser: :chrome, options: options)
  ### Allow file downloads in Google Chrome when headless!!!
  ### https://bugs.chromium.org/p/chromium/issues/detail?id=696481#c89
  bridge = driver.browser.send(:bridge)
  path = '/session/:session_id/chromium/send_command'
  path[':session_id'] = bridge.session_id
  bridge.http.call(:post, path, cmd: 'Page.setDownloadBehavior',
                   params: {
                       behavior: 'allow',
                       downloadPath: CAPYBARA_DOWNLOAD_DIR
                   })
  driver
end

Before("@selenium_chrome_headless_downloading") do
  FileUtils.rm_rf(CAPYBARA_DOWNLOAD_DIR)
  FileUtils.mkdir_p(CAPYBARA_DOWNLOAD_DIR)
end

#Make sure the browser is big enough - a few of the tests will send input to the wrong place if
# it is not wide enough.
Before("@javascript") do
  Capybara.current_session.current_window.resize_to(1600, 1200)
end

require 'capybara/email'
World(Capybara::Email::DSL)

# puts "Compiling webpack"
# Dir.chdir(Rails.root) do
#   system("RAILS_ENV=test bundle exec rake webpacker:compile")
# end
# puts "Webpack compiled"

#Uncommenting the following will look at the HTML after each step. If it has not yet been seen it will be
# dumped into Rails.root/tmp/html_dump. Also a file named 'manifest' will be dumped that associates the
# html files to the url that was active at the time.
# Then you can run the vnu tool on the directory to see if there are any html errors
# I do something like this: java -jar $HOME/bin/vnu.jar --errors-only *.html > errors 2>&1
# Currently there are:
# - a valign error that seems to emanate from datatables
# - an error that appears to come from the datepicker: " Table columns in range 3…6 established by element “th” have no cells beginning in them."
# , but any others should be fixable within this application.
 require_relative('html_dumper')
# HtmlDumper.instance.activate
 AfterStep do
   begin
     HtmlDumper.instance.dump(page)
   rescue Exception => e
     puts "Problem dumping html: #{e}"
   end
 end

# SimpleCov.start 'rails' do
#   #command_name 'features'
#   merge_timeout 1.week.to_i
# end
